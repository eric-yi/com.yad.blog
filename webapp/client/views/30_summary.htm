<div class="storycontent">
<p>Java程序员在编码过程中通常不需要考虑内存问题，JVM经过高度优化的GC机制大部分情况下都能够很好地处理堆(Heap)的清理问题。以至于许多Java程序员认为，我只需要关心何时创建对象，而回收对象，就交给GC来做吧！甚至有人说，如果在编程过程中频繁考虑内存问题，是一种退化，这些事情应该交给编译器，交给虚拟机来解决。</p>
<p>这话其实也没有太大问题，的确，大部分场景下关心内存、GC的问题，显得有点“杞人忧天”了，高老爷说过：</p>
<blockquote><p>过早优化是万恶之源。</p></blockquote>
<p>但另一方面，<span style="color: #ff0000;"><strong>什么才是“过早优化”？</strong></span></p>
<blockquote><p>If we could do things right for the first time, why not?</p></blockquote>
<p>事实上<span style="color: #ff0000;"><strong>JVM的内存模型</strong></span>( <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/" onclick="javascript:_gaq.push(['_trackEvent','outbound-article','http://www.cs.umd.edu']);" target="_blank"><span style="color: #008000;">JMM</span></a> )理应是Java程序员的基础知识，处理过几次JVM线上内存问题之后就会很明显感受到，很多系统问题，都是内存问题。</p>
<p>对JVM内存结构感兴趣的同学可以看下 <a href="http://blog.hesey.net/2011/04/introduction-to-java-virtual-machine.html"  target="_blank"><span style="color: #008000;">浅析Java虚拟机结构与机制</span></a> 这篇文章，本文就不再赘述了，本文也并不关注具体的GC算法，相关的文章汗牛充栋，随时可查。</p>
<p>另外，不要指望GC优化的这些技巧，可以对应用性能有成倍的提高，特别是对I/O密集型的应用，或是实际落在YoungGC上的优化，可能效果只是帮你减少那么一点YoungGC的频率。</p>
<p>但我认为，<span style="color: #ff0000;"><strong>优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著</strong></span>，就像前面说的，<span style="color: #ff0000;"><strong>如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢</strong></span>？
<a class="more-link" href="javascript:readArticle(30)">(more…)</a>
</p>
</div>
